<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>晟自然 - 驗電器 (Project D)</title>
    
    <style>
        /* --- 1. 全局定義 (繼承系列作風格) --- */
        :root {
            --header-h: 56px;
            --footer-h: 96px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
            --primary: #2c3e50;
            --accent: #3498db;
            --highlight: #e74c3c;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('page.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            touch-action: none;
            user-select: none;
        }

        /* --- 2. Header --- */
        header {
            flex: 0 0 var(--header-h);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
            justify-content: space-between;
        }

        .brand-group { display: flex; align-items: center; gap: 12px; }
        .logo { height: 34px; border-radius: 6px; }
        h1 { font-size: 1.15rem; color: var(--primary); margin: 0; font-weight: 700; letter-spacing: 0.5px; }

        /* --- 3. Stage --- */
        #canvas-stage {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-stage:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        /* 說明標籤 (增強版) */
        .instruction-tag {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            color: #444;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none;
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            text-align: center;
        }

        .instruction-tag.highlight {
            border-color: var(--accent);
            color: var(--primary);
            background: #fff;
        }
        
        .instruction-tag.alert {
            border-color: var(--highlight);
            color: var(--highlight);
            background: #fff0f0;
        }

        /* --- 4. Footer --- */
        .control-deck {
            flex: 0 0 var(--footer-h);
            background: rgba(255, 255, 255, 0.98);
            border-top: 1px solid rgba(0,0,0,0.05);
            padding-bottom: var(--safe-bottom);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .switch-capsule {
            display: flex;
            background: #f1f3f5;
            padding: 6px;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            align-items: center;
        }

        .divider { width: 1px; height: 30px; background: #ccc; margin: 0 10px; }

        .btn-toggle {
            width: 60px;
            height: 50px;
            border: none;
            border-radius: 50px;
            font-size: 1.4rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: transparent;
            color: #bdc3c7;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-text { font-size: 1rem; width: auto; padding: 0 20px; }
        .btn-toggle:active { transform: scale(0.95); }
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.5); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.5); }
        
        .deck-label { font-size: 0.9rem; font-weight: 700; color: #666; margin-right: 8px;}

    </style>
</head>
<body>

    <header>
        <div class="brand-group">
            <img src="logo.jpg" alt="Logo" class="logo">
            <h1>晟自然輔助系統　驗電器</h1>
        </div>
    </header>

    <div id="canvas-stage">
        <div class="instruction-tag" id="infoTag">步驟1：請拖曳帶電棒靠近驗電器</div>
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="control-deck">
        <div class="switch-capsule">
            <span class="deck-label" style="padding-left:10px">帶電棒</span>
            <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">－</button>
            <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">＋</button>
            
            <div class="divider"></div>
            
            <button class="btn-toggle btn-text" style="font-size:0.9rem; color:#e74c3c" onclick="APP.reset()">
                ↺ 重置實驗
            </button>
        </div>
    </div>

<script>
/**
 * Project D: Electroscope (V1)
 * Features:
 * 1. Structure: Metal Disc (Top) + Gold Leaves (Bottom) + Glass Bottle.
 * 2. Logic A (Induction): Rod near -> Leaves Open.
 * 3. Logic B (Contact): Rod touches -> Charge Transfer -> Leaves Stay Open.
 * 4. Logic C (Testing): Charged Electroscope + Same Rod -> Wider; Opp Rod -> Close.
 */
const APP = {
    canvas: null,
    ctx: null,
    wrapper: null,
    width: 0,
    height: 0,
    dpr: 1,

    // 核心物件
    electroscope: { 
        x: 0, y: 0, 
        netCharge: 0, // 0: Neutral, >0: Pos, <0: Neg
        leafAngle: 0, // 0 ~ PI/2
        plateR: 60,   // 金屬盤半徑
        bottleW: 160,
        bottleH: 220
    },
    
    rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 

    // 粒子 (視覺用)
    particles: [], // 電子 (藍)
    protons: [],   // 質子 (紅, 固定)

    state: {
        inductionVal: 0, // 感應強度 (-1 ~ 1), 負代表棒子是負電
        isTouching: false,
        msgState: 0 // 文字狀態
    },

    CONFIG: {
        rodLen: 100, rodW: 34,
        particleSize: 12,
        maxLeafAngle: 1.2, // 最大張角 (弧度)
    },

    init: function() {
        this.wrapper = document.getElementById('canvas-stage');
        this.canvas = document.getElementById('simCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.dpr = window.devicePixelRatio || 1;

        window.addEventListener('resize', () => this.resize());
        
        const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
        bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
        bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));

        this.resize();
        this.reset();
        this.loop();
    },

    resize: function() {
        const rect = this.wrapper.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;
        this.ctx.scale(this.dpr, this.dpr);

        // 驗電器置中
        this.electroscope.x = this.width / 2;
        this.electroscope.y = this.height / 2 + 50; // 略往下放

        this.rodSize = {
            L: this.CONFIG.rodLen,
            W: this.CONFIG.rodW
        };
        
        // 如果重置時位置不對，這裡會校正
        if (!this.rod.dragging) {
            this.rod.x = this.width * 0.8; 
            this.rod.y = this.height * 0.8;
        }
    },

    reset: function() {
        this.electroscope.netCharge = 0;
        this.electroscope.leafAngle = 0;
        this.state.isTouching = false;
        
        this.rod.x = this.width * 0.8;
        this.rod.y = this.height * 0.8;
        this.rod.angle = -Math.PI/4;
        
        this.initParticles();
        this.updateInstruction();
    },

    initParticles: function() {
        this.particles = [];
        this.protons = [];
        
        const ex = this.electroscope.x;
        const ey = this.electroscope.y; // 這是瓶身中心
        const plateY = ey - this.electroscope.bottleH/2 - 20; // 金屬盤位置
        const leafY = ey + 20; // 金箔位置

        // 1. 質子 (固定背景)
        // 金屬盤上
        for(let i=0; i<5; i++) {
            this.protons.push({x: ex + (Math.random()-0.5)*80, y: plateY + (Math.random()-0.5)*20});
        }
        // 金屬桿與金箔上
        for(let i=0; i<3; i++) {
            this.protons.push({x: ex, y: ey - 50 + i*30});
        }
        // 金箔位置 (左右各一)
        this.protons.push({x: ex - 15, y: leafY + 40});
        this.protons.push({x: ex + 15, y: leafY + 40});

        // 2. 電子 (初始中性 = 數量與質子相同)
        // 為了模擬流動，我們建立一個電子池
        let eCount = this.protons.length; 
        for(let i=0; i<eCount; i++) {
            // 隨機分佈在盤與箔
            let isTop = Math.random() > 0.5;
            let ty = isTop ? plateY : leafY + 30;
            this.particles.push({
                x: ex + (Math.random()-0.5)*40,
                y: ty + (Math.random()-0.5)*40,
                vx: 0, vy: 0,
                targetY: ty // 目標高度 (用於動畫流動)
            });
        }
    },

    update: function() {
        // --- 1. Rod Geometry (V6 Clamp) ---
        let targetX = this.rod.x; 
        let targetY = this.rod.y; // 這裡簡化，直接用 rod.x/y 因為在 drag 中已處理
        
        // 計算棒頭位置 (用於感應)
        let halfL = this.rodSize.L / 2;
        let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
        let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;
        
        // --- 2. Induction Physics ---
        // 計算棒頭到 "金屬盤" 的距離
        let plateY = this.electroscope.y - this.electroscope.bottleH/2 - 20;
        let dist = Math.sqrt(Math.pow(tipX - this.electroscope.x, 2) + Math.pow(tipY - plateY, 2));
        
        let influence = 0;
        let threshold = 250;
        if (dist < threshold) {
            influence = (1 - dist/threshold);
        }
        
        // 感應值: 正棒為正，負棒為負
        this.state.inductionVal = influence * this.rod.charge;

        // --- 3. Contact Logic ---
        // 棒頭半徑 + 金屬盤半徑
        if (dist < this.electroscope.plateR + 20) {
            if (!this.state.isTouching) {
                this.state.isTouching = true;
                // 接觸瞬間轉移電荷
                // 負棒接觸 -> 注入電子 -> netCharge 變負
                // 正棒接觸 -> 吸走電子 -> netCharge 變正
                // 我們簡單增加/減少 netCharge 數值
                if (this.rod.charge === -1) this.electroscope.netCharge -= 50; 
                else this.electroscope.netCharge += 50;
                
                // 限制最大電荷
                if (this.electroscope.netCharge < -100) this.electroscope.netCharge = -100;
                if (this.electroscope.netCharge > 100) this.electroscope.netCharge = 100;
            }
        } else {
            this.state.isTouching = false;
        }

        // --- 4. Leaf Angle Physics (The Core) ---
        // 金箔張角取決於 "底部的電荷密度"
        // BottomCharge = NetCharge + InducedShift
        // InducedShift: 
        //   若棒子是負(-)，排斥電子到底部 -> 底部變更負 -> Angle UP
        //   若棒子是正(+)，吸引電子到頂部 -> 底部變更正 -> Angle UP
        
        // 電荷位移量 (由感應引起)
        // 假設感應最大可造成 +/- 40 的電荷位移
        // 負棒 (inductionVal < 0) -> 電子下移 -> 底部獲得負電 (-40)
        // 正棒 (inductionVal > 0) -> 電子上移 -> 底部失去負電 (變成正 +40)
        
        // 這裡要小心符號：
        // 設 shift 為 "底部獲得的電荷量"
        // Rod(-) -> shift 是負的 (電子多了)
        // Rod(+) -> shift 是正的 (電子少了，變正)
        let inducedShiftAtBottom = this.state.inductionVal * 40; // 符號與棒子相同
        
        // 底部總電荷量 (絕對值決定張角)
        // 當 netCharge = 0, Angle = abs(induced) -> 張開 (同性)
        // 當 netCharge != 0 (e.g. +50)
        //    Rod(+) -> shift (+40) -> Total (+90) -> 張更開 (Scenario C)
        //    Rod(-) -> shift (-40) -> Total (+10) -> 閉合 (Scenario C)
        let bottomTotalQ = this.electroscope.netCharge + inducedShiftAtBottom;
        
        // 計算目標角度
        let targetAngle = Math.min(this.CONFIG.maxLeafAngle, Math.abs(bottomTotalQ) * 0.015);
        // 動畫阻尼
        this.electroscope.leafAngle += (targetAngle - this.electroscope.leafAngle) * 0.1;

        // --- 5. Particle Animation Logic ---
        // 我們不模擬真實物理，而是根據 "狀態" 分配電子位置
        // 總電子數 = 基礎(中性) - (netCharge / 10)
        let baseCount = this.protons.length; 
        let desiredE = Math.floor(baseCount - (this.electroscope.netCharge / 20)); // 淨電荷越大，電子越少(正)或越多(負)
        
        // 增減粒子
        if (this.particles.length < desiredE) {
            this.particles.push({ x: this.electroscope.x, y: plateY, vx:0, vy:0 });
        } else if (this.particles.length > desiredE) {
            this.particles.pop();
        }

        // 分配目標位置 (TargetY)
        // 如果 inductionVal < 0 (負棒) -> 電子被趕到底部
        // 如果 inductionVal > 0 (正棒) -> 電子被吸到頂部
        // 如果 netCharge != 0，多餘電荷均勻分佈
        
        // 簡化演算法：計算 "頂部親和力" vs "底部親和力"
        // TopAffinity = 棒子吸引力 (正棒吸電子)
        // BotAffinity = 棒子排斥力 (負棒推電子)
        
        let topBias = 0.5; // 預設 50/50
        if (this.state.inductionVal > 0) topBias = 0.9; // 正棒，大部分電子在上面
        if (this.state.inductionVal < 0) topBias = 0.1; // 負棒，大部分電子在下面
        
        let leafY = this.electroscope.y + 20;

        this.particles.forEach((p, i) => {
            // 決定這顆粒子該去哪
            // 使用雜湊或索引決定，避免全部一起跑
            let myTarget = (Math.random() < 0.05) ? (Math.random() < topBias ? plateY : leafY + 40) : p.targetY;
            p.targetY = myTarget;
            
            // 移動
            let dy = (p.targetY - p.y);
            p.y += dy * 0.1; // 垂直移動
            
            // 水平隨機抖動 (模擬氣體/自由電子)
            p.x += (Math.random()-0.5) * 4;
            // 限制在瓶寬內
            let limitW = (p.y > plateY + 20) ? 30 : 50; // 下面窄一點
            if (p.x > this.electroscope.x + limitW) p.x = this.electroscope.x + limitW;
            if (p.x < this.electroscope.x - limitW) p.x = this.electroscope.x - limitW;
        });

        this.updateInstruction();
    },

    updateInstruction: function() {
        const tag = document.getElementById('infoTag');
        const net = this.electroscope.netCharge;
        const angle = this.electroscope.leafAngle;
        const rodQ = this.rod.charge;
        
        let msg = "";
        let className = "instruction-tag";
        
        if (Math.abs(net) < 10) {
            // 中性
            if (angle > 0.1) {
                msg = "靜電感應：電荷分離，金箔張開";
                className += " highlight";
            } else {
                msg = "步驟1：請拖曳帶電棒靠近或接觸金屬盤";
            }
        } else {
            // 帶電中
            let qType = net > 0 ? "正" : "負";
            
            if (this.state.isTouching) {
                msg = "接觸起電中...";
                className += " alert";
            } else {
                // 判斷情境 C
                // 如果目前帶正電，棒子也是正 -> 張更開
                // 如果目前帶正電，棒子是負 -> 閉合
                let interaction = "";
                if (angle < 0.1) interaction = " (異性相吸 -> 閉合)";
                else if (angle > 0.8 && angle > Math.abs(net)*0.015) interaction = " (同性相斥 -> 更開)";
                
                msg = `驗電器帶${qType}電${interaction}`;
                className += " success";
            }
        }

        if (tag.innerText !== msg) tag.innerText = msg;
        tag.className = className;
    },

    // --- Drawing ---
    draw: function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        this.drawElectroscope();
        
        // 粒子繪製
        this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
        this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));

        this.drawRod();
        
        if (this.state.isTouching) this.drawSpark();
    },

    drawElectroscope: function() {
        let ex = this.electroscope.x;
        let ey = this.electroscope.y;
        let bh = this.electroscope.bottleH;
        let bw = this.electroscope.bottleW;
        
        // 1. 金屬桿 (Center Rod)
        this.ctx.fillStyle = "#95a5a6";
        this.ctx.fillRect(ex - 4, ey - bh/2 - 20, 8, bh - 60);

        // 2. 金箔 (Leaves) - 根據角度旋轉
        // 金箔根部
        let hingeY = ey + 20; 
        let leafL = 60;
        let angle = this.electroscope.leafAngle;

        this.ctx.save();
        this.ctx.translate(ex, hingeY);
        
        // 左葉
        this.ctx.save();
        this.ctx.rotate(-angle);
        this.ctx.fillStyle = "#f1c40f"; // Gold
        this.ctx.fillRect(-6, 0, 6, leafL);
        // 畫一點紋理
        this.ctx.strokeStyle = "#d4ac0d";
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(-6, 0, 6, leafL);
        this.ctx.restore();

        // 右葉
        this.ctx.save();
        this.ctx.rotate(angle);
        this.ctx.fillStyle = "#f1c40f";
        this.ctx.fillRect(0, 0, 6, leafL);
        this.ctx.strokeRect(0, 0, 6, leafL);
        this.ctx.restore();

        this.ctx.restore();

        // 3. 玻璃瓶 (Bottle)
        this.ctx.save();
        this.ctx.beginPath();
        // 鐘罩形狀
        this.ctx.moveTo(ex - bw/2, ey + bh/2); // 左下
        this.ctx.lineTo(ex + bw/2, ey + bh/2); // 右下
        this.ctx.lineTo(ex + bw/2, ey - bh/3); // 右肩
        this.ctx.quadraticCurveTo(ex + bw/2, ey - bh/2, ex + 20, ey - bh/2); // 右圓角
        this.ctx.lineTo(ex - 20, ey - bh/2); // 頂部頸口
        this.ctx.quadraticCurveTo(ex - bw/2, ey - bh/2, ex - bw/2, ey - bh/3); // 左圓角
        this.ctx.closePath();
        
        // 玻璃質感
        this.ctx.fillStyle = "rgba(230, 240, 255, 0.3)";
        this.ctx.fill();
        this.ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        // 瓶底木座
        this.ctx.fillStyle = "#5d4037";
        this.ctx.fillRect(ex - bw/2 - 10, ey + bh/2, bw + 20, 15);
        this.ctx.restore();

        // 4. 金屬盤 (Disc) - 最上面
        let plateY = ey - bh/2 - 20;
        let pr = this.electroscope.plateR;
        
        // 畫一個扁的橢圓
        this.ctx.beginPath();
        this.ctx.ellipse(ex, plateY, pr, pr*0.3, 0, 0, Math.PI*2);
        this.ctx.fillStyle = "#bdc3c7";
        this.ctx.fill();
        this.ctx.strokeStyle = "#7f8c8d";
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // 盤的厚度
        this.ctx.beginPath();
        this.ctx.moveTo(ex - pr, plateY);
        this.ctx.lineTo(ex - pr, plateY + 10);
        this.ctx.ellipse(ex, plateY + 10, pr, pr*0.3, 0, 0, Math.PI, false); // 下半弧
        this.ctx.lineTo(ex + pr, plateY);
        this.ctx.fillStyle = "#95a5a6";
        this.ctx.fill();
    },

    drawCharge: function(x, y, color, symbol) {
        const r = 8;
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI*2);
        this.ctx.fillStyle = '#fff';
        this.ctx.fill();
        this.ctx.lineWidth = 1;
        this.ctx.strokeStyle = color;
        this.ctx.stroke();

        this.ctx.fillStyle = color;
        this.ctx.font = `bold 12px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(symbol, x, y + 1);
    },

    drawRod: function() {
        this.ctx.save();
        this.ctx.translate(this.rod.x, this.rod.y);
        this.ctx.rotate(this.rod.angle); 

        const L = this.rodSize.L;
        const W = this.rodSize.W;
        const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
        const symbol = this.rod.charge < 0 ? '-' : '+';
        
        // 棒身
        this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
        this.ctx.beginPath();
        this.ctx.roundRect(-L/2, -W/2, L, W, W/2);
        this.ctx.fill();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 1;
        this.ctx.stroke();

        // 棒頭
        const headX = L/2 - W/2;
        const headR = W * 0.8;
        this.ctx.beginPath();
        this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
        this.ctx.fillStyle = '#fff'; 
        this.ctx.fill();
        this.ctx.strokeStyle = chargeColor; 
        this.ctx.lineWidth = 4;
        this.ctx.stroke();

        this.ctx.fillStyle = chargeColor;
        this.ctx.font = 'bold 28px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(symbol, headX, 2);

        // 握把
        this.ctx.fillStyle = '#2c3e50';
        this.ctx.fillRect(-L/2, -W/2, 40, W); 
        this.ctx.restore();
    },
    
    drawSpark: function() {
        let halfL = this.rodSize.L / 2;
        let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
        let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;
        
        this.ctx.save();
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = "yellow";
        this.ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
        this.ctx.beginPath();
        this.ctx.arc(tipX, tipY, 15, 0, Math.PI*2);
        this.ctx.fill();
        this.ctx.restore();
    },

    handleMouse: function(e) {
        if (e.type === 'mousedown') {
            this.rod.dragging = true;
            this.drag(e);
        } else if (e.type === 'mousemove') {
            if(this.rod.dragging) this.drag(e);
        } else if (e.type === 'mouseup' || e.type === 'mouseleave') {
            this.rod.dragging = false;
        }
    },

    handleTouch: function(e) {
        e.preventDefault();
        if (e.type === 'touchstart') {
            this.rod.dragging = true;
            this.drag(e);
        } else if (e.type === 'touchmove') {
            if(this.rod.dragging) this.drag(e);
        } else if (e.type === 'touchend') {
            this.rod.dragging = false;
        }
    },

    drag: function(e) {
        const rect = this.canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        let x = clientX - rect.left;
        let y = clientY - rect.top;

        // 鉗制邏輯
        let dx = this.electroscope.x - x;
        let dy = this.electroscope.y - y;
        let angle = Math.atan2(dy, dx);
        
        let halfL = this.rodSize.L / 2;
        // 這裡允許棒頭進入，但限制棒身不要穿模太誇張
        this.rod.angle = angle;
        this.rod.x = x - Math.cos(angle) * halfL;
        this.rod.y = y - Math.sin(angle) * halfL;
    },

    setRod: function(c) {
        this.rod.charge = c;
        // 換棒子時，是否要重置驗電器？
        // 為了教學方便，通常換棒子 = 新實驗，所以重置
        // 但如果要做 "情境C"，需要保留電荷...
        // 這裡先不重置 netCharge，只重置位置，方便做實驗
        // this.electroscope.netCharge = 0; // 註解掉這行
        
        this.rod.x = this.width * 0.8;
        this.rod.y = this.height * 0.8;
        this.rod.angle = -Math.PI/4;
        
        document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
        document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
        this.updateInstruction();
    },

    loop: function() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

window.onload = () => APP.init();

</script>
</body>
</html>