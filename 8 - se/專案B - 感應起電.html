<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÊôüËá™ÁÑ∂ - ÊÑüÊáâËµ∑Èõª (V6)</title>
    
    <style>
        /* --- 1. ÂÖ®Â±ÄÂÆöÁæ© --- */
        :root {
            --header-h: 56px;
            --footer-h: 96px;
            --safe-bottom: env(safe-area-inset-bottom, 10px);
            --primary: #2c3e50;
            --accent: #3498db;
            --highlight: #e74c3c;
            --ground: #27ae60; 
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('page.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            touch-action: none;
            user-select: none;
        }

        /* --- 2. Header --- */
        header {
            flex: 0 0 var(--header-h);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
            justify-content: space-between;
        }

        .brand-group { display: flex; align-items: center; gap: 12px; }
        .logo { height: 34px; border-radius: 6px; }
        h1 { font-size: 1.15rem; color: var(--primary); margin: 0; font-weight: 700; letter-spacing: 0.5px; }

        /* --- 3. Stage --- */
        #canvas-stage {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-stage:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        .instruction-tag {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 24px;
            border-radius: 50px;
            font-size: 1rem;
            color: #444;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none;
            white-space: nowrap;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .instruction-tag.step-active {
            color: var(--primary);
            border-color: var(--accent);
            background: #fff;
        }
        
        .instruction-tag.success {
            color: #fff;
            background: var(--ground);
            border-color: var(--ground);
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.4);
        }

        /* --- 4. Footer --- */
        .control-deck {
            flex: 0 0 var(--footer-h);
            background: rgba(255, 255, 255, 0.98);
            border-top: 1px solid rgba(0,0,0,0.05);
            padding-bottom: var(--safe-bottom);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .switch-capsule {
            display: flex;
            background: #f1f3f5;
            padding: 6px;
            border-radius: 100px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
            align-items: center;
        }

        .divider { width: 1px; height: 30px; background: #ccc; margin: 0 10px; }

        .btn-toggle {
            width: 60px;
            height: 50px;
            border: none;
            border-radius: 50px;
            font-size: 1.4rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: transparent;
            color: #bdc3c7;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-text { font-size: 1rem; width: auto; padding: 0 20px; }
        .btn-toggle:active { transform: scale(0.95); }
        .btn-toggle.active-neg { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.5); }
        .btn-toggle.active-pos { background: #e74c3c; color: white; box-shadow: 0 4px 12px rgba(231, 76, 60, 0.5); }
        
        .btn-ground { color: #95a5a6; transition: 0.3s; }
        .btn-ground.active {
            background: var(--ground);
            color: white;
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.5);
        }
        
        /* Á¶ÅÁî®ÁãÄÊÖã */
        .btn-ground.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .deck-label { font-size: 0.9rem; font-weight: 700; color: #666; margin-right: 8px;}

    </style>
</head>
<body>

    <header>
        <div class="brand-group">
            <img src="logo.jpg" alt="Logo" class="logo">
            <h1>ÊôüËá™ÁÑ∂ËºîÂä©Á≥ªÁµ±„ÄÄÊÑüÊáâËµ∑Èõª</h1>
        </div>
    </header>

    <div id="canvas-stage">
        <div class="instruction-tag" id="infoTag">Ê≠•È©ü1ÔºöË´ãÊãñÊõ≥Â∏∂ÈõªÊ£íÈù†ËøëÈáëÂ±¨ÁêÉ</div>
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="control-deck">
        <div class="switch-capsule">
            <span class="deck-label" style="padding-left:10px">Â∏∂ÈõªÊ£í</span>
            <button class="btn-toggle active-neg" id="btnNeg" onclick="APP.setRod(-1)">Ôºç</button>
            <button class="btn-toggle" id="btnPos" onclick="APP.setRod(1)">Ôºã</button>
            
            <div class="divider"></div>
            
            <button class="btn-toggle btn-text btn-ground" id="btnGround" onclick="APP.toggleGround()">
                üñê Êé•Âú∞
            </button>
            
            <div class="divider"></div>
            <button class="btn-toggle btn-text" style="font-size:0.9rem; color:#e74c3c" onclick="APP.reset()">
                ‚Ü∫ ÈáçÁΩÆ
            </button>
        </div>
    </div>

<script>
/**
 * Project B: Induction Charging (V6 Optimized)
 * V6 Updates:
 * 1. Base: Larger, Dark Brown (#5d4037) pedestal.
 * 2. Logic: No Induction (Rod far) -> Ground button does NOTHING.
 * 3. Text: Explanation stays ON SCREEN until disconnected.
 * 4. Physics: Stronger attraction force for Positive Rod to clump 8 electrons tightly.
 */
const APP = {
    canvas: null,
    ctx: null,
    wrapper: null,
    width: 0,
    height: 0,
    dpr: 1,

    // Â†¥ÊôØÁâ©‰ª∂
    conductor: { x: 0, y: 0, r: 0 },
    rod: { x: 0, y: 0, charge: -1, dragging: false, angle: 0 }, 
    
    // Á≤íÂ≠êÁ≥ªÁµ±
    particles: [], 
    protons: [],   
    flowParticles: [], 
    
    state: {
        inductionLevel: 0,
        isGrounded: false,
        flowTimer: 0
    },

    CONFIG: {
        radiusBase: 90,     
        particleSize: 15,
        
        k_rod: 120000, // Âü∫Á§éÂäõ
        k_self: 8000, 
        damping: 0.85, 
        
        rodLen: 100,        
        rodW: 34,           
        gap: 50,            
        inductionThreshold: 160,
        
        groundY: 0,
        wireX: 0
    },

    init: function() {
        this.wrapper = document.getElementById('canvas-stage');
        this.canvas = document.getElementById('simCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.dpr = window.devicePixelRatio || 1;

        window.addEventListener('resize', () => this.resize());
        
        const bind = (evts, handler) => evts.forEach(e => this.canvas.addEventListener(e, handler, {passive: false}));
        bind(['mousedown', 'mousemove', 'mouseup', 'mouseleave'], e => this.handleMouse(e));
        bind(['touchstart', 'touchmove', 'touchend'], e => this.handleTouch(e));

        this.resize();
        this.loop();
    },

    resize: function() {
        const rect = this.wrapper.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;
        this.ctx.scale(this.dpr, this.dpr);

        this.conductor.x = this.width / 2;
        this.conductor.y = this.height / 2 - 60; 
        this.CONFIG.groundY = this.height - 40; 
        
        let scale = Math.min(this.width, this.height) / 400;
        this.conductor.r = this.CONFIG.radiusBase * scale;
        this.CONFIG.wireX = this.conductor.x + this.conductor.r + 30; 
        
        this.rodSize = {
            L: this.CONFIG.rodLen * scale,
            W: this.CONFIG.rodW * scale
        };

        if (this.protons.length === 0) {
            this.initParticles();
            this.rod.x = this.width * 0.85; 
            this.rod.y = this.height * 0.85;
        }
    },

    reset: function() {
        this.state.isGrounded = false;
        this.state.flowTimer = 0;
        this.flowParticles = [];
        this.rod.x = this.width * 0.85;
        this.rod.y = this.height * 0.85;
        this.rod.angle = -Math.PI/4;
        this.initParticles();
        this.updateUI();
    },

    initParticles: function() {
        this.particles = [];
        this.protons = [];
        const {x, y, r} = this.conductor;
        const offset = r * 0.4;

        // Âõ∫ÂÆö 4 ÂÄãË≥™Â≠êÔºåÂàùÂßã 4 ÂÄãÈõªÂ≠ê (‰∏≠ÊÄß)
        const pos = [
            {x: x-offset, y: y-offset}, {x: x+offset, y: y-offset},
            {x: x-offset, y: y+offset}, {x: x+offset, y: y+offset}
        ];

        pos.forEach(p => {
            this.protons.push({x: p.x, y: p.y});
            this.particles.push({
                x: p.x + (Math.random()-0.5)*5,
                y: p.y + (Math.random()-0.5)*5,
                vx: 0, vy: 0
            });
        });
    },

    update: function() {
        // --- 1. Rod Physics ---
        let dxRod = this.conductor.x - this.rod.x;
        let dyRod = this.conductor.y - this.rod.y;
        this.rod.angle = Math.atan2(dyRod, dxRod); 
        let halfL = this.rodSize.L / 2;
        let tipX = this.rod.x + Math.cos(this.rod.angle) * halfL;
        let tipY = this.rod.y + Math.sin(this.rod.angle) * halfL;

        // --- 2. Induction Logic ---
        let distToCenter = Math.sqrt(dxRod*dxRod + dyRod*dyRod);
        let surfaceDist = distToCenter - this.conductor.r - halfL;
        let maxEffectDist = this.CONFIG.inductionThreshold;
        if (surfaceDist < 0) surfaceDist = 0;
        
        if (surfaceDist > maxEffectDist) {
            this.state.inductionLevel = 0;
        } else {
            this.state.inductionLevel = 1 - (surfaceDist / maxEffectDist);
        }

        // V6: Â¶ÇÊûúÊ≤íÊúâÊÑüÊáâÔºåÂº∑Âà∂Êñ∑ÈñãÊé•Âú∞ (Â¶ÇÊûú‰πãÂâçÊé•‰∏äÁöÑË©±ÔºåË¶ñÁÇ∫ÊâãÊîæÈñã)
        // ‰ΩÜÈ°åÁõÆË™™ "ÈªûÊé•Âú∞Ê≤íÂèçÊáâ"ÔºåÊâÄ‰ª•ÈÄôË£°ÊòØÈò≤Ê≠¢Ëá™ÂãïËß∏Áôº„ÄÇ
        // Â¶ÇÊûúÊ£íÂ≠êÁßªÈÅ†ÔºåÁâ©ÁêÜ‰∏ä‰æÜË™™Êé•Âú∞ÈÇÑÊòØÂú®Ôºå‰ΩÜÊÑüÊáâÈõªËç∑ÊúÉÊµÅÂõû„ÄÇ
        // ÈÄôË£°ÊàëÂÄëÂè™ËôïÁêÜ "ÊåâÁ¥ê" ÁöÑÈò≤ÂëÜ

        // --- 3. Grounding Logic ---
        this.updateGroundingLogic();

        // --- 4. Particle Physics ---
        const pR = this.CONFIG.particleSize * (this.width/400);
        const scale = this.width / 400;
        
        // V6: Stronger force for Positive Rod to ensure tight clumping
        let forceMult = (this.rod.charge === 1) ? 2.5 : 1.0; 
        const rodForceBase = this.CONFIG.k_rod * scale * forceMult;
        const selfForceBase = this.CONFIG.k_self * scale;

        this.particles.forEach((p) => {
            let fx = 0, fy = 0;
            
            // Rod Force
            let dx = p.x - tipX;
            let dy = p.y - tipY;
            let distSq = dx*dx + dy*dy;
            
            // Allow closer approach for tighter packing
            let minD = (this.rod.charge === 1) ? 60 : 100;
            if (distSq < minD) distSq = minD;
            
            let rodF = rodForceBase / distSq;
            let dist = Math.sqrt(distSq);

            if (this.state.inductionLevel > 0) {
                if (this.rod.charge === -1) { 
                    fx += (dx / dist) * rodF; fy += (dy / dist) * rodF; 
                } else { 
                    fx -= (dx / dist) * rodF; fy -= (dy / dist) * rodF; 
                }
            }

            // Self Repulsion
            this.particles.forEach((other) => {
                if (p === other) return;
                let odx = p.x - other.x;
                let ody = p.y - other.y;
                let od2 = odx*odx + ody*ody;
                let od = Math.sqrt(od2);
                if (od < 0.1) od = 0.1;
                
                let repF = selfForceBase / (od2 + 10);
                fx += (odx/od) * repF;
                fy += (ody/od) * repF;
            });

            p.vx = (p.vx + fx) * this.CONFIG.damping;
            p.vy = (p.vy + fy) * this.CONFIG.damping;
            
            let speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
            if (speed > 8) {
                p.vx = (p.vx/speed)*8;
                p.vy = (p.vy/speed)*8;
            }

            p.x += p.vx;
            p.y += p.vy;
        });

        // Resolve Constraints
        const iterations = 3; 
        for(let k=0; k<iterations; k++) {
            this.particles.forEach((p, i) => {
                // Boundary
                let cdx = p.x - this.conductor.x;
                let cdy = p.y - this.conductor.y;
                let cDist = Math.sqrt(cdx*cdx + cdy*cdy);
                let limitR = this.conductor.r - pR - 2;

                if (cDist > limitR) {
                    let ang = Math.atan2(cdy, cdx);
                    p.x = this.conductor.x + limitR * Math.cos(ang);
                    p.y = this.conductor.y + limitR * Math.sin(ang);
                    p.vx *= 0.1; 
                    p.vy *= 0.1;
                }

                // Collision
                for (let j = i + 1; j < this.particles.length; j++) {
                    let p2 = this.particles[j];
                    let dx = p.x - p2.x;
                    let dy = p.y - p2.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let minDist = pR * 2 + 2; 

                    if (dist < minDist) {
                        let overlap = minDist - dist;
                        let nx = dx / dist;
                        let ny = dy / dist;
                        p.x += nx * overlap * 0.5;
                        p.y += ny * overlap * 0.5;
                        p2.x -= nx * overlap * 0.5;
                        p2.y -= ny * overlap * 0.5;
                    }
                }
            });
        }

        this.updateFlowParticles();
        this.updateInstruction();
    },

    updateGroundingLogic: function() {
        if (!this.state.isGrounded) return;
        // Â¶ÇÊûúÊé•Âú∞‰∏≠Ôºå‰ΩÜÊ£íÂ≠êÁßªÈñã‰∫Ü (level < 0.2)ÔºåÈõªÂ≠êÊúÉÊµÅÂõû
        // ÈÄôË£°ÁÇ∫‰∫ÜÊºîÁ§∫ÊïàÊûúÔºåÂ¶ÇÊûúÊé•Âú∞‰∏îÊúâÊÑüÊáâÔºåÊâçÈÄ≤Ë°åÊï∏ÈáèË™øÊï¥
        if (this.state.inductionLevel < 0.2) return; 

        this.state.flowTimer++;
        if (this.state.flowTimer < 10) return; 
        
        let currentCount = this.particles.length;
        let targetCount = 4; 
        if (this.rod.charge === 1) targetCount = 8;
        if (this.rod.charge === -1) targetCount = 0;

        if (currentCount < targetCount) {
            if (this.flowParticles.length === 0) {
                this.spawnFlowParticle('up');
                this.state.flowTimer = 0;
            }
        } else if (currentCount > targetCount) {
            if (this.flowParticles.length === 0) {
                this.particles.pop(); 
                this.spawnFlowParticle('down');
                this.state.flowTimer = 0;
            }
        }
    },

    spawnFlowParticle: function(dir) {
        let wireX = this.CONFIG.wireX;
        let startY = (dir === 'up') ? this.CONFIG.groundY : this.conductor.y;
        
        this.flowParticles.push({
            x: wireX,
            y: startY,
            vy: (dir === 'up') ? -20 : 20, 
            dir: dir,
            active: true
        });
    },

    updateFlowParticles: function() {
        for(let i = this.flowParticles.length-1; i>=0; i--) {
            let p = this.flowParticles[i];
            p.y += p.vy;
            
            let hitSphere = (p.dir === 'up' && p.y <= this.conductor.y);
            let hitGround = (p.dir === 'down' && p.y >= this.CONFIG.groundY);

            if (p.active) {
                if (hitSphere) {
                    this.particles.push({
                        x: this.conductor.x + this.conductor.r - 10,
                        y: this.conductor.y,
                        vx: -5, vy: 0
                    });
                    p.active = false;
                } else if (hitGround) {
                    p.active = false;
                }
            }

            if (p.y < this.conductor.y - 100 || p.y > this.CONFIG.groundY + 100 || !p.active) {
                this.flowParticles.splice(i, 1);
            }
        }
    },

    updateInstruction: function() {
        const tag = document.getElementById('infoTag');
        const level = this.state.inductionLevel;
        const grounded = this.state.isGrounded;
        const eCount = this.particles.length;
        
        let msg = "";
        let className = "instruction-tag";
        
        if (!grounded) {
            if (level < 0.2) {
                if (eCount === 4) {
                    msg = "Ê≠•È©ü1ÔºöË´ãÊãñÊõ≥Â∏∂ÈõªÊ£íÈù†ËøëÈáëÂ±¨ÁêÉ";
                    className += " step-active";
                } else {
                    let charge = eCount > 4 ? "Ë≤†" : "Ê≠£";
                    msg = `ÂØ¶È©óÂÆåÊàêÔºöÈáëÂ±¨ÁêÉÂ∏∂${charge}Èõª`;
                    className += " success";
                }
            } else {
                msg = "Ê≠•È©ü2ÔºöÂ∏∂ÈõªÊ£í‰∏çÂãïÔºåÈªûÊìä‰∏ãÊñπ„ÄåÊé•Âú∞„Äç";
                className += " step-active";
            }
        } else {
            let isBalanced = false;
            if (this.rod.charge === 1 && eCount === 8) isBalanced = true;
            if (this.rod.charge === -1 && eCount === 0) isBalanced = true;
            
            if (isBalanced) {
                 msg = "Ê≠•È©ü3ÔºöË´ã„ÄåÊñ∑ÈñãÊé•Âú∞„ÄçÈéñÂÆöÈõªËç∑";
            } else {
                 msg = "Ê≠•È©ü3ÔºöËßÄÂØüÈõªÂ≠êÊµÅÂãïÊñπÂêë";
            }
            className += " step-active";
        }
        
        if (!grounded && level >= 0.2 && eCount !== 4) {
            msg = "Ê≠•È©ü4ÔºöË´ãÁßªÈñãÂ∏∂ÈõªÊ£í";
        }

        if (tag.innerText !== msg) tag.innerText = msg;
        tag.className = className;
    },

    toggleGround: function() {
        // V6 Èò≤ÂëÜÔºöÊ≤íÊúâÊÑüÊáâÊôÇÔºå‰∏çÂÖÅË®±Êé•Âú∞
        if (this.state.inductionLevel < 0.2) {
            // ÂèØ‰ª•ÈÅ∏Êìá‰∏çÂÅö‰ªª‰Ωï‰∫ãÔºåÊàñËÄÖÈñÉÁàçÊèêÁ§∫
            // ÈÄôË£°ÈÅ∏ÊìáÁõ¥Êé•ÁÑ°Êïà
            return;
        }
        this.state.isGrounded = !this.state.isGrounded;
        this.updateUI();
    },

    updateUI: function() {
        const btn = document.getElementById('btnGround');
        if (this.state.isGrounded) {
            btn.classList.add('active');
            btn.innerText = "üñê Êñ∑Èñã";
        } else {
            btn.classList.remove('active');
            btn.innerText = "üñê Êé•Âú∞";
        }
    },

    draw: function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        this.drawFloor();
        this.drawConductor(); 
        
        if (this.state.isGrounded) {
            this.drawGroundSystem();
        }
        
        this.protons.forEach(p => this.drawCharge(p.x, p.y, '#e74c3c', '+'));
        this.particles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));
        this.flowParticles.forEach(p => this.drawCharge(p.x, p.y, '#3498db', '-'));

        this.drawRod();
    },

    drawFloor: function() {
        const y = this.CONFIG.groundY;
        this.ctx.lineCap = 'butt';
        
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(this.width, y);
        this.ctx.strokeStyle = '#7f8c8d'; 
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        this.ctx.beginPath();
        for(let i=0; i<this.width; i+=25) {
            this.ctx.moveTo(i, y);
            this.ctx.lineTo(i-15, y+15);
        }
        this.ctx.strokeStyle = '#95a5a6';
        this.ctx.lineWidth = 1;
        this.ctx.stroke();
    },

    drawGroundSystem: function() {
        const y = this.CONFIG.groundY;
        const wireX = this.CONFIG.wireX;
        const {x, r} = this.conductor;
        const cy = this.conductor.y;

        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // 1. Â∞éÁ∑ö (Wire)
        this.ctx.beginPath();
        this.ctx.moveTo(x + r + 20, cy); 
        this.ctx.lineTo(wireX, cy); 
        this.ctx.lineTo(wireX, y); 
        this.ctx.strokeStyle = '#000000'; 
        this.ctx.lineWidth = 4;
        this.ctx.stroke();

        // 2. Êé•Âú∞Á¨¶Ëôü (Symbol)
        this.ctx.strokeStyle = '#000000'; 
        this.ctx.lineWidth = 4;
        
        this.ctx.beginPath();
        this.ctx.moveTo(wireX, y);
        this.ctx.lineTo(wireX, y + 15);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(wireX - 18, y + 15);
        this.ctx.lineTo(wireX + 18, y + 15);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(wireX - 12, y + 22);
        this.ctx.lineTo(wireX + 12, y + 22);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(wireX - 6, y + 29);
        this.ctx.lineTo(wireX + 6, y + 29);
        this.ctx.stroke();

        // 3. ÊâãÊåá
        this.ctx.save();
        this.ctx.font = "40px Arial";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.translate(x + r + 15, cy + 15);
        this.ctx.rotate(-1.57); 
        this.ctx.fillText("üëÜ", 0, 0);
        this.ctx.restore();

        // 4. ÈõªÂ≠êÊµÅÂãïË™™Êòé (Label) - V6: Â∏∏ÈßêÈ°ØÁ§∫ÔºåÁõ¥Âà∞Êñ∑Èñã
        // Âè™Ë¶Å grounded ÁÇ∫ trueÔºåÂ∞±Ê†πÊìöÊ£íÂ≠êÈõªÊÄßÈ°ØÁ§∫Â∞çÊáâÊñáÂ≠ó
        if (this.state.isGrounded) {
             let chars = [];
             let arrow = "";
             
             if (this.rod.charge === 1) { // Positive Rod -> In
                chars = ["Èõª","Â≠ê","Âæû","Âú∞","ÁêÉ","ÊµÅ","ÂÖ•"];
                arrow = "‚Üë";
             } else { // Negative Rod -> Out
                chars = ["Èõª","Â≠ê","Âæû","Èáë","Â±¨","ÁêÉ","ÊµÅ","Âá∫"];
                arrow = "‚Üì";
             }
             
             if (chars.length > 0) {
                 this.ctx.fillStyle = "#2c3e50"; 
                 this.ctx.font = "bold 24px 'Microsoft JhengHei', Arial"; 
                 this.ctx.textAlign = "center";
                 this.ctx.textBaseline = "middle";

                 let textX = wireX - 45;
                 let centerY = (y + cy) / 2;
                 let startY = centerY - (chars.length * 28) / 2;
                 
                 for(let i=0; i<chars.length; i++) {
                     this.ctx.fillText(chars[i], textX, startY + i*28);
                 }
                 
                 this.ctx.fillStyle = "#e74c3c"; 
                 this.ctx.font = "bold 40px Arial";
                 this.ctx.fillText(arrow, wireX + 40, centerY);
             }
        }
    },

    drawConductor: function() {
        const {x, y, r} = this.conductor;
        
        // V6: Â∫ïÂ∫ß (Pedestal) - Dark Brown, Larger
        this.ctx.fillStyle = '#5d4037'; 
        // Áï´Âú®Âú∞Èù¢‰∏äÊñπ
        let baseW = 80;
        let baseH = 15;
        this.ctx.fillRect(x - baseW/2, this.CONFIG.groundY - baseH, baseW, baseH);

        // ÁµïÁ∑£Êü± (Stand)
        let standW = 16;
        let standH = (this.CONFIG.groundY - baseH) - (y + r);
        this.ctx.fillStyle = '#95a5a6';
        this.ctx.fillRect(x - standW/2, y + r - 2, standW, standH + 2);
        
        // ÈáëÂ±¨ÁêÉ
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI*2);
        let grad = this.ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
        grad.addColorStop(0, '#f8f9fa');
        grad.addColorStop(1, '#95a5a6');
        this.ctx.fillStyle = grad;
        this.ctx.fill();

        // Â§ñÊ°Ü
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI*2);
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.stroke();
    },

    drawCharge: function(x, y, color, symbol) {
        const r = this.CONFIG.particleSize * (this.width / 400); 
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI*2);
        this.ctx.fillStyle = '#fff';
        this.ctx.fill();
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = color;
        this.ctx.stroke();

        this.ctx.fillStyle = color;
        this.ctx.font = `bold ${r*1.2}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(symbol, x, y + 1);
    },

    drawRod: function() {
        this.ctx.save();
        this.ctx.translate(this.rod.x, this.rod.y);
        this.ctx.rotate(this.rod.angle); 

        const L = this.rodSize.L;
        const W = this.rodSize.W;
        const chargeColor = this.rod.charge < 0 ? '#3498db' : '#e74c3c';
        const symbol = this.rod.charge < 0 ? '-' : '+';
        
        // Ê£íË∫´
        this.ctx.fillStyle = (this.rod.charge < 0) ? '#34495e' : 'rgba(236, 240, 241, 0.95)';
        this.ctx.beginPath();
        this.ctx.roundRect(-L/2, -W/2, L, W, W/2);
        this.ctx.fill();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 1;
        this.ctx.stroke();

        // Ê£íÈ†≠
        const headX = L/2 - W/2;
        const headR = W * 0.8;
        this.ctx.beginPath();
        this.ctx.arc(headX, 0, headR, 0, Math.PI*2);
        this.ctx.fillStyle = '#fff'; 
        this.ctx.fill();
        this.ctx.strokeStyle = chargeColor; 
        this.ctx.lineWidth = 4;
        this.ctx.stroke();

        this.ctx.fillStyle = chargeColor;
        this.ctx.font = 'bold 28px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(symbol, headX, 2);

        // Êè°Êää
        this.ctx.fillStyle = '#2c3e50';
        this.ctx.fillRect(-L/2, -W/2, 40, W); 
        this.ctx.strokeStyle = '#555';
        this.ctx.lineWidth = 2;
        for(let i=0; i<3; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(-L/2 + 10 + i*10, -W/2);
            this.ctx.lineTo(-L/2 + 10 + i*10, W/2);
            this.ctx.stroke();
        }

        this.ctx.restore();
    },

    handleMouse: function(e) {
        if (e.type === 'mousedown') this.startDrag(e);
        else if (e.type === 'mousemove') this.drag(e);
        else if (e.type === 'mouseup' || e.type === 'mouseleave') this.endDrag(e);
    },

    handleTouch: function(e) {
        e.preventDefault();
        if (e.type === 'touchstart') this.startDrag(e);
        else if (e.type === 'touchmove') this.drag(e);
        else if (e.type === 'touchend') this.endDrag(e);
    },

    getPos: function(e) {
        const rect = this.canvas.getBoundingClientRect();
        let cx, cy;
        if (e.touches) {
            cx = e.touches[0].clientX;
            cy = e.touches[0].clientY;
        } else {
            cx = e.clientX;
            cy = e.clientY;
        }
        return { x: cx - rect.left, y: cy - rect.top };
    },

    startDrag: function(e) {
        let p = this.getPos(e);
        let dist = Math.sqrt(Math.pow(p.x - this.rod.x, 2) + Math.pow(p.y - this.rod.y, 2));
        if (dist < 150) {
            this.rod.dragging = true;
            this.updateRodPos(p.x, p.y);
        }
    },

    drag: function(e) {
        if (!this.rod.dragging) return;
        let p = this.getPos(e);
        this.updateRodPos(p.x, p.y);
    },

    endDrag: function() {
        this.rod.dragging = false;
    },

    updateRodPos: function(targetX, targetY) {
        // V15 Tip-Centric Boundary
        let dxRod = this.conductor.x - targetX;
        let dyRod = this.conductor.y - targetY;
        let angle = Math.atan2(dyRod, dxRod);

        let halfL = this.rodSize.L / 2;
        let tipX = targetX + Math.cos(angle) * halfL;
        let tipY = targetY + Math.sin(angle) * halfL;

        tipX = Math.max(0, Math.min(this.width, tipX));
        tipY = Math.max(0, Math.min(this.height, tipY));

        this.rod.x = tipX - Math.cos(angle) * halfL;
        this.rod.y = tipY - Math.sin(angle) * halfL;

        let finalDx = this.conductor.x - this.rod.x;
        let finalDy = this.conductor.y - this.rod.y;
        let dist = Math.sqrt(finalDx*finalDx + finalDy*finalDy);
        let minSafeDist = halfL + this.conductor.r + this.CONFIG.gap;

        if (dist < minSafeDist) {
             this.rod.x = this.conductor.x - Math.cos(angle) * minSafeDist;
             this.rod.y = this.conductor.y - Math.sin(angle) * minSafeDist;
        }
    },

    setRod: function(c) {
        this.rod.charge = c;
        this.reset(); 
        document.getElementById('btnNeg').className = c===-1 ? 'btn-toggle active-neg' : 'btn-toggle';
        document.getElementById('btnPos').className = c===1 ? 'btn-toggle active-pos' : 'btn-toggle';
    },

    loop: function() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

window.onload = () => APP.init();

</script>
</body>
</html>